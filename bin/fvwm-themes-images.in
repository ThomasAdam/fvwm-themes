#!@PERL@ -w
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

#-----------------------------------------------------------------------------
# Copyright 2000, Olivier Chapuis
#-----------------------------------------------------------------------------

# Filter this script to pod2man to get a man page:
#   pod2man -c "Fvwm Utility" fvwm-themes-images | nroff -man | less -e

#use strict;
use Getopt::Long;

my $version = '@VERSION@';
my $fvwmVersion = '@FVWM_VERSION@';
my $ftDataDir = '@FT_DATADIR@';
my @xlibPath = qw(@X_LIBS@ @X_EXTRA_LIBS@);
my $scriptName = ($0 =~ m:([^/]+)$:, $1);
my $ftImagesDir = "$ftDataDir/images";

my $userHome = $ENV{'HOME'} || "./.";
# default directory for "transformed" icons
my $siteTransformOutDir = "$ftDataDir/tr-images";
my $userTransformOutDir = "$userHome/tr-images";

my @pathDirs = split(':',$ENV{PATH});
my $userName = $ENV{USER} || "unknown";

# global options
my $inDir = "";
my $outDir = "";
my $inFile = "";
my $outFile = "";

# for storing the rgb.txt file
my %rgb;

# convert options
my $convert = 0;
my $gnome = 0;
my $postfix = "";
my $transFilter = 1;
my @types = ();
my $preserve = 0;
my %build = (
	'48x48' => 1,
	'16x16' => 1,
	'56x56' => 0,
	'32x32' => 0,
	'tiles' => 0,
);
my %tileOpt = (
	'48x48' => "",
	'16x16' => "",
	'56x56' => "",
	'32x32' => "",
	'tiles' => "",
);
my %addBorderOpt = (
	'48x48' => "",
	'16x16' => "",
	'56x56' => "",
	'32x32' => "",
	'tiles' => "",
);
my %size = (
	'48x48' => "48x48",
	'16x16' => "17x17",  # huh?
	'56x56' => "56x56",
	'32x32' => "32x32",
	'tiles' => "",
);

# tile options
my $tile = "";

# add border
my $addBorder = "";

# ImageMagick options
my $magickColors = 256;
my $colorspace = "Transparent";
# depends if ImageMagick is compiled with 16bits per pixels enabled!
# if yes percentage is taken with 65535 if no 255 is used
my $threshold = 70;
my $magickPath = "";
my $magickBpp = 0;

# cde-sky option
my $patternFile = "$ftDataDir/themes/cde/background/pattern";
my $patternType = "";
my $patternXpm = "";
my $gradColorsOpt = "";
my $cdeSky = 0;
my $patternGap = 1;
my $patternY = "";
my $gradComp = "linear";

# set the background
my $setBackground = 0;
my $setBackProg = "xpmroot";
my $setBackFile = "/tmp/$userName-ft-back.xpm";

# rotate
my $rotate = 0;

# colorize
my $colorize = 0;
my $rizeColorsOpt = "gray40:gray60";
my $transColor = "";
my $rizeComp = "l";
my $rizeRule = "max";

# Info
my $xcolorsInfo = 0;
my $xcolorsetsInfo = 0;
my $colorToShow = undef;

# colors shemes
my $colorsSchemes = 0;
my $createTextColors = "";
my $schemePostfix = "dp";

# others
my $verbose = 1;
my $verboseOpt = -1;
my $site = 0;
my $createSymLink = "";
my $install = 0;
my $update = 0;
my $debug = "";
my $beFast = 0;

# constant (these constant are in main:: because this speed the code)
my @Hex=(0 .. 9, "a" .. "f");
my $singleIdList =
	q( .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk) .
	q(lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|);
# ` <- stupid fix for my stupid Xemacs! olicha

GetOptions(
	"help"               => \&showHelp,
	"version"            => \&showVersion,
	"in-dir=s"           => \$inDir,
	"out-dir=s"          => \$outDir,
	"in-file=s"          => \$inFile,
	"out-file=s"         => \$outFile,
	"magick-path=s"      => \$magickPath,
	"magick-bpp=i"       => \$magickBpp,
	"magick-colors=i"    => \$magickColors,
	"magick-space=s"     => \$colorspace,
	"convert"            => \$convert,
	"gnome"              => \$gnome,
	"postfix"            => \$postfix,
	"trans-filter!"      => \$transFilter,
	"48x48-size=s"       => \$size{"48x48"},
	"56x56-size=s"       => \$size{"56x56"},
	"32x32-size=s"       => \$size{"32x32"},
	"16x16-size=s"       => \$size{"16x16"},
	"tiles-size=s"       => \$size{"tiles"},
	"build-16x16!"       => \$build{"16x16"},
	"build-48x48!"       => \$build{"48x48"},
	"build-56x56!"       => \$build{"56x56"},
	"build-32x32!"       => \$build{"32x32"},
	"build-tiles!"       => \$build{"tiles"},
	"preserve"           => \$preserve,
	"tile-48x48=s"       => \$tileOpt{"48x48"},
	"tile-16x16=s"       => \$tileOpt{"16x16"},
	"tile-56x56=s"       => \$tileOpt{"56x56"},
	"tile-32x32=s"       => \$tileOpt{"32x32"},
	"tile-tiles=s"       => \$tileOpt{"tiles"},
	"add-border-48x48=s" => \$addBorderOpt{"48x48"},
	"add-border-16x16=s" => \$addBorderOpt{"16x16"},
	"add-border-56x56=s" => \$addBorderOpt{"56x56"},
	"add-border-32x32=s" => \$addBorderOpt{"32x32"},
	"add-border-tiles=s" => \$addBorderOpt{"tiles"},
	"tile=s"             => \$tile,
	"add-border=s"       => \$addBorder,
	"threshold=i"        => \$threshold,
	"colorize-colors=s"  => \$rizeColorsOpt,
	"colorize"           => \$colorize,
	"trans-color=s"      => \$transColor,
	"colorize-comp=s"    => \$rizeComp,
	"colorize-rule=s"    => \$rizeRule,
	"cde-sky"            => \$cdeSky,
	"sky-colors=s"       => \$gradColorsOpt,
	"pattern-file=s"     => \$patternFile,
	"pattern-type=s"     => \$patternType,
	"pattern-xpm=s"      => \$patternXpm,
	"pattern-gap=s"      => \$patternGap,
	"pattern-y=i"        => \$patternY,
	"sky-comp=s"         => \$gradComp,
	"set-background"     => \$setBackground,
	"set-back-prog=s"    => \$setBackProg,
	"rotate=s"           => \$rotate,
	"show-xcolors"       => \$xcolorsInfo,
	"show-xcolorsets"    => \$xcolorsetsInfo,
	"show-color-info=s"  => \$colorToShow,
	"verbose=i"          => \$verboseOpt,
	"site"               => \$site,
	"create-symlink=s"   => \$createSymLink,
	"update"             => \$update,
	"ft-install"         => \$install,
	"be-fast"            => \$beFast,
	"colors-schemes"     => \$colorsSchemes,
	"text-colors=s"      => \$createTextColors,
	"schemes-ext=s"      => \$schemePostfix,
) || wrongUsage();

# compute verbosity!
if ($setBackground) {
	$verbose = 0;
}
if ($verboseOpt != -1) {
	$verbose = $verboseOpt;
}

if ($install) {
	$site = 1;
	$gnome = 1;
	$convert = 1;
	$update = 1;
	$createSymLink = "48x48:16x16";
}

die "--convert and --set-background are incompatible\n"
	if $setBackground && $convert;

if ($xcolorsInfo || $xcolorsetsInfo) {
	showXcolorsInfo($xcolorsetsInfo);
	exit;
}

if (defined $colorToShow) {
	showColorInfo($colorToShow);
	exit;
}

if ($cdeSky) {
	cdeSky();
	exit;
}

# see if we have to check magic:
if ($convert || $tile =~ /expand/) {
	($magickPath,$magickBpp) = checkMagick();
}

$convert = 1 if $gnome;

if ($convert) {
	foreach (keys %build) {
		push @types, $_ if $build{$_};
	}
	@types = ("preserve") if $preserve;
	transform();
	exit;
}

if ($tile || $addBorder || $colorize || $rotate ne "0") {
	@types = ("preserve");
	transform();
	exit;
}

if ($createSymLink ne "") {
	@types = ();
	transform();
	exit;
}

if ($colorsSchemes) {
	colorsSchemes();
	exit;
}

#------------------------------------------------------------------------------
# Transform, main "convert" procedure
#------------------------------------------------------------------------------

sub transform {
	my $type;
	my $dirtype;
	my $dir;
	my $sizeOpt;

	if ($gnome) {
		my $testExecFile = 'gnome-session';
		my $defaultGnomeInstallDir = '/usr';

		my $gnomeInstallDir = getExecFileDir($testExecFile);
		$gnomeInstallDir =~ s,/$,,;
		$gnomeInstallDir =~ 	s,/[-A-Za-z]+$,,;
		$gnomeInstallDir =~ s,/$,,;
		$gnomeInstallDir = $defaultGnomeInstallDir
			if $gnomeInstallDir eq 'not found';
		$inDir = "$gnomeInstallDir/share/pixmaps";
		$postfix = "gnome";
		$inFile = "";
		$outFile = "";
	}

	$inDir = "$inDir/" unless $inDir =~ /\/$/ || $inDir eq "";
	if ($inDir !~ /^\// && $inFile !~ /^\//) {
		my $tmp =`pwd`;
		chomp($tmp);
		$inDir ="$tmp/$inDir";
	}

	if ($inFile ne "") {
		if ($inFile =~ /\//) {
			my $index = rindex($inFile,"/");
			if ($inFile =~ /^\//) {
				$inDir = substr($inFile,0,$index);
			} else {
				$inDir = "$inDir" . substr($inFile,0,$index);
			}
			$inFile = substr($inFile,$index+1);
		}
		die "No such file: $inDir/$inFile !" unless -f "$inDir/$inFile";
	}
	$inDir =~ s/\/$//;

	my $transformOutDir = $userTransformOutDir;
	$transformOutDir = $siteTransformOutDir if $site;
	$outDir = "$transformOutDir/$outDir" if ($outDir eq "");

	if ($inFile ne "" && $outFile eq "" && !$convert) {
		if ($setBackground) { $outFile = "$setBackFile"; }
		else {
			die "If you specify an in-file you must specify an out-file\n" .
				"(but for --set-background and convert)\n";
		}
	}

	if ($outDir !~ /^\// && $outFile !~ /^\//) {
		my $tmp =`pwd`;
		chomp($tmp);
		$outDir ="$tmp/$outDir";
	}
	$outDir = "$outDir/" unless $outDir =~ /\/$/ || $outDir eq "";
	if ($outFile ne "") {
		if ($outFile =~ /\//) {
			my $index = rindex($outFile,"/");
			if ($outFile =~ /^\//) { $outDir = substr($outFile,0,$index); }
			else { $outDir = "$outDir" . substr($outFile,0,$index);}
			$outFile = substr($outFile,$index+1);
		}
	}
	$outDir =~ s/\/$//;

	-d $outDir || mkdir("$outDir", 0775) ||
		die "impossible to create $outDir \n\t (we do not create more than one".
			" level of directory).\n";


	# compute the threshold:
	if ($convert && $transFilter) {
		if ($threshold > 100) { $threshold = 100; }
		if ($threshold < 0) { $threshold = 0; }
		$threshold = int(((2**$magickBpp)-1)*($threshold/100));
	}

	# compute the postfix
	$postfix = "-".$postfix if $postfix ne "";

	for $type (@types) {

		if ($type eq "preserve") {
			$dirtype = "";
			$sizeOpt = "";
			$dir = $inDir;
		} elsif ($type eq "tiles") {
			$dir = "$inDir/tiles";
			$dirtype = "/$type$postfix";
			$sizeOpt = "-geometry $size{$type}" if $size{$type} ne "";
		} else {
			$dir = $inDir;
			$dirtype = "/$type$postfix";
			$sizeOpt = "-geometry $size{$type}" if $size{$type} ne "";
		}

		-d "$outDir$dirtype" || mkdir("$outDir$dirtype", 0775) ||
			die "impossible to create $outDir$dirtype";

		# tile ?
		my $haveToTile = 0;
		my $tileXpm; my $tileType;
		my ($xTile,$yTile) = (0, 0);
		if ($convert && $tileOpt{$type} ne "") {
			($tileXpm,$tileType,$xTile,$yTile) = getTile("$tileOpt{$type}");
			$haveToTile = 1;
		} elsif ($tile ne "") {
			($tileXpm,$tileType,$xTile,$yTile) = getTile("$tile");
			$haveToTile = 1;
		}

		# add border ?
		my $haveToAddBorder = 0;
		my ($xBorder, $yBorder) = (0, 0);
		my $borderColor = "Gray0";
		if ($convert && $addBorderOpt{$type} =~ /^\+(\d+)\+(\d+):*(.*)/) {
			$xBorder = $1; $yBorder = $2;
			$borderColor = $3; $haveToAddBorder = 1;
		} elsif ($addBorder =~ /^\+(\d+)\+(\d+):*(.*)/) {
			$xBorder = $1; $yBorder = $2;
			$borderColor = $3; $haveToAddBorder = 1;
		}

		my $unlinkmask = 0;

		my $info = "";
		my $infoType = "";
		if ($convert) {
			$info .= "convert ";
			$infoType .= "$type xpm";
		}
		$info .= "rotate " if ($rotate);
		$info .= "colorize " if ($colorize);
		$info .= "tile " if ($haveToTile);
		$info .= "borderize " if ($haveToAddBorder);
		$info .= " (update) " if ($update);
		if ($inFile eq "") {
			myPrint (2,"-------------------------------------------\n");
			myPrint (1,"$info images in $dir\ninto $type xpm images " .
			  "in $outDir$dirtype\n");
			myPrint (2,"\n");
		}

		my @fileList;
		if ($inFile eq "") { @fileList = scanDir($dir);}
		else { @fileList = ("$inFile"); }

		my $file = "";

		foreach $file (@fileList) {
			my $xpmFile = "";
			my $mainXpm = 0;
			my $xpmdir = $dir;

			if ($convert) {
				$xpmFile = changeIconFilename($file);
				next if $update && -f "$outDir$dirtype/$xpmFile";
			}
			if ($convert) {
				myPrint (1,"transform $file ...");
				myPrint(2,"\n\t convert to $type xpm ... ");
				system("$magickPath/convert -colors $magickColors $sizeOpt ".
					"-colorspace $colorspace $dir/$file $outDir$dirtype/$xpmFile");
				$xpmdir = "$outDir$dirtype";
				myPrint(2,"done");
			} elsif ($colorize || $tile || $addBorder || $rotate) {
				next unless $file =~ /.xpm$/;
				$xpmFile = $file;
				next if ($update && -f "$outDir$dirtype/$xpmFile");
				myPrint (1,"transform $file ...");
			}

			if ($convert && hasMatte("$dir/$file") && $transFilter &&
				$file !~ /.xpm$/) {
				myPrint(2,"\n\t transparent filter ... ");
		 		system("$magickPath/convert -mono -colorspace $colorspace ".
					"-layers Matte".
					" $sizeOpt -threshold $threshold ".
					"$dir/$file $outDir$dirtype/.mask.xpm");
				$unlinkmask = 1;
		 		$mainXpm = loadXpm("$outDir$dirtype/$xpmFile");
				my $maskXpm = loadXpm("$outDir$dirtype/.mask.xpm");
				applyTrans($mainXpm, $maskXpm,"None");
				myPrint(2,"done");
			}

			if ($rotate ne "0") {
				myPrint(2,"\n\t rotate ... ");
				$mainXpm = loadXpm("$xpmdir/$xpmFile")
					if ref($mainXpm) ne "HASH";
				rotateXpm($mainXpm,$rotate);
				myPrint(2,"done");
			}

			if ($colorize) {
				myPrint(2,"\n\t colorize ... ");
				$mainXpm = loadXpm("$xpmdir/$xpmFile")
					if ref($mainXpm) ne "HASH";
				colorizeXpm($mainXpm);
				myPrint(2,"done");
			}

			if ($haveToTile) {
				myPrint(2,"\n\t tile ... ");
				$mainXpm = loadXpm("$xpmdir/$xpmFile")
					if ref($mainXpm) ne "HASH";
				applyTile($mainXpm,$tileXpm,$tileType,$xTile,$yTile);
				myPrint(2,"done");
			}

			if ($haveToAddBorder) {
				myPrint(2,"\n\t add border ... ");
				$mainXpm = loadXpm("$xpmdir/$xpmFile")
					if ref($mainXpm) ne "HASH";
				addBorder($mainXpm,$xBorder,$xBorder,$yBorder,$yBorder,
					$borderColor);
				myPrint(2,"done");
			}


			$xpmFile = $outFile if ($inFile ne "" && $outFile ne "");
			writeXpm($mainXpm,"$outDir$dirtype/$xpmFile")
				if ref($mainXpm->{'def'}) eq "ARRAY";

			myPrint(2,"\n");
			myPrint(1, "done\n");
			myPrint(2,"\n");
		}
		unlink("$outDir$dirtype/.mask.xpm") if $unlinkmask;
	}

	if ($setBackground && $outFile ne "") {
		setBack("$outDir/$outFile");
	}

	if ($createSymLink ne "") {
		createSymLink();
	}

}

#-----------------------------------------------------------------------------
# useful func for transform

# parse a tile option and return the good xpm
sub getTile($) {
	my $tile = shift;
	my $xpm;
	my $type = "tile";
	my ($x,$y) = (0, 0);

	if ($tile =~ /^\s*color:(.*)\s*/) {
		my $color = $1;
		if ($color =~ /^\+(\d+)\+(\d+):(.*)/) {
			$color = encode16bpp($3);
			$x=$1; $y=$2;
		}
		$xpm = createMonoXpm(1,1,$color);
	} elsif ($tile =~ /^\s*expand:(.*)\s*/) {
		$xpm = $1;
		if ($xpm =~ /^\+(\d+)\+(\d+):(.*)/) {
			$xpm = $3;
			$x=$1; $y=$2;
		}
		die "no tile xpm $tile" unless -f $xpm;
		$type = "expand";
	} elsif ($tile =~ /^\s*center:(.*)\s*/) {
		$tile = $1;
		if ($tile =~ /^\+(\d+)\+(\d+):(.*)/) {
			$tile = $3;
		}
		die "no tile xpm $tile" unless -f $tile;
		$xpm = loadXpm($tile);
		$type = "center";
	}  elsif ($tile =~ /^\s*tile:(.*)\s*/) {
		$tile = $1;
		if ($tile =~ /^\+(\d+)\+(\d+):(.*)/) {
			$tile = $3;
			$x=$1; $y=$2;
		}
		die "no tile xpm $tile" unless -f $tile;
		$xpm = loadXpm($tile);
	} else {
		if ($tile =~ /^\+(\d+)\+(\d+):(.*)/) {
			$tile = $3;
			$x=$1; $y=$2;
		}
		die "no tile xpm $tile" unless -f $tile;
		$xpm = loadXpm($tile);
	}
	return ($xpm,$type,$x,$y);
}

#-------------------------------------
# FROM fvwm2gnome
sub changeIconFilename {
	my ($iconName) = @_;
	my $xpmString = "xpm";

	my $choppedIconName = substr($iconName, 0, -3);
	$iconName = "$choppedIconName$xpmString";
	return $iconName;
}

sub scanDir {
	my ($scanPath) = @_;
	my  @dirList = ();
	opendir(DIR, "$scanPath") || die "cannot open dir $scanPath\n";
	foreach (readdir(DIR)) {
		# must be fixed one day: found all the formats supported
		# by ImageMagick ...
		push @dirList, $_
			if (/.png$/ || /.xpm$/ || /.jpg$/ || /.gif$/);
	}
	closedir(DIR);
	return(@dirList);
}

#-------------------------------------
#

sub getExecFileDir($) {
	my $execFile = shift;
	my $done = 0;
	my $return = 'not found';
	foreach (@pathDirs) {
		my $test = "$_/$execFile";
		return $_ if -x  $test;
	}
	return $return;
}

#-------------------------------------
# create the symlink: need more work

sub createSymLink {
	my $i = 0;
	my $type;
	my @dest = split(":",$createSymLink);
	@dest = map { "$outDir/$_$postfix" } @dest;
	die "No directory to link!\n"
		unless -d $dest[0] && -d $dest[1];
	myPrint(1,"Create symbolic link\n");
	foreach $type ("norm", "mini") {
		unlink("$ftImagesDir/$type$postfix");
		symlink("$dest[$i]","$ftImagesDir/$type$postfix") ||
			die "Can't symlink $dest[$i] to $ftImagesDir/$type$postfix";
		myPrint(2,"symlink $dest[$i] to $ftImagesDir/$type$postfix\n");
		$i++;
	}
}

#-------------------------------------
# check for Image Magick: there is now a Magick-config, but
# old (and very good) version of ImageMagick does not have it.

sub checkMagick {
	my $dir  = "";
	my $bpp = $magickBpp;

	myPrint(2,"\n");
	myPrint(1,"Check for ImageMagick ...");
	if ($magickPath eq "") {
		$dir = getExecFileDir("convert");
		$dir =~ s/\/$//;
		if	($dir eq 'not found') {
			die "Gasp\nconvert from ImageMagick was not found!!\n".
				"\t use the --magick-path option or install ImageMagick.\n"
		}
	} else {
		$dir = $magickPath;
		$dir =~ s/\/$//;
		if (! -x "$dir/convert") {
			die "Gasp\nconvert from ImageMagick was not found in:\n".
				"\t$dir, check the --magick-path option\n";
		}
	}
	myPrint(1," Ok\n");

	open(VER,"$dir/convert|");
	my @version = <VER>;
	close(VER);
	my $verLine = $version[0];
	myPrint(2, "$verLine");
	if ($magickBpp == 0 && $verLine =~ /Q:([0-9][0-9]*)/) {
		$bpp = "$1";
		myPrint(2, "QuantumLeap: $bpp\n");
	} elsif ($magickBpp == 0) {
		$bpp = 16;
		myPrint(1,"WARN: QuantumLeap: no indication from ImageMagick\n".
			"\t 16 is assumed (see the -magick-bpp option)\n");
	}

	return ($dir,$bpp);
}

#------------------------------------------------------------------------------
# cde-sky (from jos-cdeskylike)
#------------------------------------------------------------------------------

sub cdeSky() {
	my @pattern=();
	my $coef;
	if ($patternType ne "") { @pattern = createPattern() }
	elsif ($patternXpm ne "") { @pattern = createPatternXpm() }
	else {
		die "pattern file $patternFile not found\n" unless -f $patternFile;
		open(INFILE,$patternFile);
		@pattern = <INFILE>;
		close(INFILE);
	}

	if ($patternY !~ /^\d+$/) {
		my ($ScreenX, $ScreenY) = `xdpyinfo|grep dimensions:` =~ / (\d+)x(\d+)/;
		$patternY = $rotate =~ /90/ ? $ScreenX:$ScreenY;
	}

	my @consPar = ();
	my $p; my $W=0; my $test = -1; my $Y=0;
	$patternGap = 1 if ($patternGap <= 0 || $patternGap !~ /^\d+$/);
	foreach $p (@pattern) {
		$test++;
		next if ($test/$patternGap != int($test/$patternGap));
		chomp($p);
		push @consPar, split("",$p);
		$Y=$Y+1;
	}
	$W=length($pattern[0]);

	my $nbrColors = 0;
	my $gradColors = [];
	my @tmp = split(':', $gradColorsOpt);
	my $c;
	foreach $c (@tmp) {
		$gradColors->[$nbrColors] = bppTo3intArray(encode16bpp($c));
		$nbrColors++;
	}

	my $NY = int($patternY/$Y)+1;
	my $dx = $NY;

	my $xpm = createMonoXpm($W,1,"None");
	my $def = $xpm->{'def'};
	my $pixels = $xpm->{'pixels'};
	my ($i,$k) = (0, 0);
	my $id; my $nextId;

	while ($i < $NY) {
		my $t; my $j = 0; my $done = 0; my $l = 0;
		if ($i == 0) {
			$t=interpolateColors($gradColors,$nbrColors,$i/$dx,$gradComp,$i);
			$id = addColor($xpm,encode16bpp($t));
		} else { $id = $nextId; }
		$t=interpolateColors($gradColors,$nbrColors,($i+1)/$dx,$gradComp,$i+1);
		$nextId=addColor($xpm,encode16bpp($t));
		$id .= " " if length($id) < length($nextId);
		while (defined $consPar[$l] && !$done) {
			$pixels->[$k]->[$j] = $consPar[$l] eq "+" ? $id:$nextId;
			$j++; $l++;
			if ($j == $W) {
				$k++; $j=0; $def->[1] = $k;
				if ($k == $patternY) { $done = 1; $i=$NY;}
			}
		}
		$i++;
	}

	rotateXpm($xpm,$rotate) if $rotate ne "0";

	$outFile = "$setBackFile" if $outFile eq "";
	writeXpm($xpm,$outFile);

	setBack("$outFile") if $setBackground;
}

#-------------------------------------
# create some pattern. Any other idea?
# Can one create the "cde-like" like pattern?

sub createPattern () {

	my $type = "uniform";
	my @pattern = ();
	my $i;
	my $coef = 1;
	my $coef2 = undef;

	# perl: '?:' may be ommited, but then $2 should be $3.
	if ($patternType =~ /^random:(\d+)(?::(\d+))?$/) {
		$type = "rand";
		$coef = $1;
		$coef2 = $2 || 8;
	} elsif ($patternType =~ /^uniform:(\d+)(?::(\d+))?$/) {
		$type = "uniform";
		$coef = $1;
		$coef2 = $2 || 8;
	} elsif ($patternType =~ /^square:(\d+)(?::(\d+))?$/) {
		$type = "square";
		$coef = $1;
		$coef2 = $2 || $coef;
	} elsif ($patternType =~ /^altern:(\d+)(?::(\d*))?$/) {
		$type = "altern";
		$coef = $1;
		$coef2 = $2 || 8;
	} elsif ($patternType =~ /^(\d+)(?::(\d+))?$/) {
		$type = "uniform";
		$coef = $1;
		$coef2 = $2 || 8;
	} else {
		die "bad pattern-type option";
	}

	if ($type eq "uniform") {
		my $p = "+" x $coef2 ."\n";
		for ($i=0; $i < $coef; $i++) { push @pattern, $p }
	}
	elsif ($type eq "altern") {
		my $p = "+" x $coef2 ."\n";
		for ($i=0; $i < $coef; $i++) { push @pattern, $p }
		$p = "-" x $coef2 ."\n";
		for ($i=0; $i < $coef; $i++) { push @pattern, $p }
	}
	elsif ($type eq "square") {
		my $p = "+" x $coef2 . "-"x$coef2 ."\n";
		for ($i=0; $i < $coef; $i++) { push @pattern, $p }
	}
	elsif ($type eq "rand") {
		for ($i=0;$i<$coef;$i++) {
			my $p = ""; my $j; my $r;
			for ($j=0; $j<$coef2; $j++) { $r= rand 1; $p .= $r > 0.5 ? "+" : "-" }
			push @pattern, "$p\n";
		}
	}
	return @pattern;
}

#-------------------------------------
# create pattern from an xpm

sub createPatternXpm () {
	my $xpm = loadXpm($patternXpm);
	my ($c,$r,$nc) = ($xpm->{'def'}->[0],$xpm->{'def'}->[1],$xpm->{'def'}->[2]);
	my $colors = $xpm->{colors};
	my $pixels = $xpm->{pixels};
	my $ids = $xpm->{ids};
	my $id = "";
	my @pattern = ();

	# found the transparent id
	my $i = 0; my $done =0;
	while($i < $nc && !$done) {
		if ($colors->[$i] eq "None") {
			$id = $ids->[$i];
			$done = 1;
		}
		$i++;
	}
	for ($i=0; $i<$r; $i++) {
		my $pm = ""; my $j;
		for ($j=0;$j<$c;$j++) { $pm .= $pixels->[$i]->[$j] eq $id ? "+" :"-"; }
		push @pattern, "$pm\n";
	}
	return @pattern;
}

#------------------------------------------------------------------------------
# colors shemes
#------------------------------------------------------------------------------

sub colorsSchemes () {
	my ($lines, $value, $white, $black) = ("","","","");
	my $createText = 0;
	my @files = ();
	my $file;

	$inDir = "$inDir/" unless $inDir =~ /\/$/ || $inDir eq "";
	if ($inDir !~ /^\//) {
		my $tmp =`pwd`;
		chomp($tmp);
		$inDir ="$tmp/$inDir";
	}
	$inDir =~ s/\/$//;

	if ($outDir !~ /^\//) {
		my $tmp =`pwd`;
		chomp($tmp);
		$outDir ="$tmp/$outDir";
	}
	$outDir =~ s/\/$// unless $outDir eq "/";

	-d $outDir || mkdir("$outDir", 0775) ||
		die "impossible to create $outDir \n\t (we do not create more than one".
			" level of directory).\n";

	opendir(DIR, "$inDir") || die "cannot open dir $inDir\n";
	foreach (readdir(DIR)) {
		push @files, $_ if  /\.$schemePostfix$/;
	}

	if ($createTextColors ne "") {
		$createText = 1;
		($lines, $value, $white, $black) = split(":",$createTextColors);
		die "Bad --create-text-colors options" 
			if ($lines !~ /^\d+$/ || (defined $value && $value !~ /^\d+$/));
		$value = 128 if !defined $value  || $value eq "";
		$white = "#ffffff" if !defined $white || $white eq "";
		$black = "#000000" if !defined $black || $black eq "";
	}

	myPrint(1,"\ntransform colors schemes *.$schemePostfix in\n".
		"\t$inDir into\n\t$outDir\n\n");

	foreach $file (@files) {
		myPrint(2,"transform $file ... ");
		open(FILE, "$inDir/$file") || die "cannot open $inDir/$file\n";
		my @f = <FILE>;
		close(FILE);
		foreach (@f) { chomp }
		my @g = ();

		if ($createText) {
			my $i = 0;
			while (defined $f[$i] && $i < $lines) {
				#chomp($f[$i]);
				$g[$i] = $f[$i];
				my $t = bppTo3intArray(encode16bpp($f[$i]));
				my $grey = greyval($t);
				if ($grey >= $value) { $g[$i+$lines] = $black }
				else { $g[$i+$lines] = $white }
				$i++;
	  	 	}
		} 
		else { @g = @f; }

		open(OUT,">$outDir/$file") || die "cannot write on $outDir/$file\n";
		foreach (@g) { print OUT ; print OUT "\n"}
		close(OUT);
		myPrint(2,"done\n");
	}
}

#------------------------------------------------------------------------------
# set the background
#------------------------------------------------------------------------------

sub setBack ($) {
	my $file = shift;
	die "no file $file" unless -f $file;
	system("$setBackProg $file");
}

#------------------------------------------------------------------------------
# Info
#------------------------------------------------------------------------------

sub formatColorInfoLine ($$$) {
	my $colorName = shift;
	my $colorRgb = encode16bpp(shift);
	my $base = shift;

	my ($r, $g, $b) = ($colorRgb =~ /^#(..)..(..)..(..)..$/);
	my $trio = bppTo3intArray($colorRgb);
	return sprintf("%-${base}s  %7s    %3d %3d %3d",
		"$colorName:", "#$r$g$b", @{$trio});
}

sub formatColorInfoHeadLine ($) {
	my $base = shift;
	return sprintf("%-${base}s  %8s   %s",
	"Color name", "8bpp RGB", "Decimal RGB");
}

sub showXcolorsInfo ($) {
	my $set = shift;
	my $base = $set ? 25 : 17;
	my $nbr;
	my $key;

	loadRGB();
	print formatColorInfoHeadLine($base), "\n\n";

	foreach $key (sort keys %rgb) {
		$nbr = $rgb{"$key"};
		print formatColorInfoLine($key, $nbr, $base), "\n";
		if ($set) {
			my $prefix;
			foreach $prefix ("shadow","hilight","random","top255","top50") {
				print formatColorInfoLine("$prefix $key", "$prefix$nbr", $base),
					"\n";
			}
			print "\n";
		}
	}
}

sub showColorInfo {
	my $color = shift;
	my $base = 25;
	loadRGB();
	my $nbr = encode16bpp("$color");
	my $a = bppTo3intArray($nbr);

	print "Information on $color:\n\n";

	my $best = 256;
	my $t;
	my @x =();
	my $key;
	foreach $key (sort keys %rgb) {
		my $b = bppTo3intArray($rgb{"$key"});
		$t =
		  sqrt(($$a[0]-$$b[0])**2+($$a[1]-$$b[1])**2+($$a[2]-$$b[2])**2)/sqrt(3);
		push @x, $key if $t == $best;
		if ($t < $best) { $best = $t; @x = ("$key"); }
	}

	if ($best == 0) {
		print "\tX color name(s): @x\n";
	} else {
		print "\tClosest X color name(s): ", join(', ',@x), " (".int($best).")\n";
	}
	print "\n";
	print "\t", formatColorInfoHeadLine($base), "\n\n";
	print "\t", formatColorInfoLine("$color", "$nbr", $base), "\n";

	my $prefix;
	foreach $prefix ("shadow", "hilight", "random", "top255", "top200",
		"top150", "top100", "top50") {
		print "\t", formatColorInfoLine("$prefix $color", "$prefix$nbr", $base),
			"\n";
	}
	print "\n";

}

#------------------------------------------------------------------------------
# an xpm lib
#------------------------------------------------------------------------------

sub loadXpm ($) {

	my $file = shift;
	my $xpm;

	open(XPM, $file) || die "Impossible to load $file";
	my $count = -1;
	my ($isColors,$isPixels) = (0, 0);
	my ($pixCount, $inComment) = (0, 0);
	my ($nc,$cpp);
	my ($i,$re);
	my $def = [];
	my $pixels = [];
	my $colors = [];
	my $ids = [];

	while(<XPM>) {
		# "in comment" need amelioration ...
		$inComment = 1 if (/^\s*\/\*/);
		if ($inComment) {
			$inComment = 0 if /\*\//;
			next;
		}
		s/^\s*//;
		next if $_ !~ /^\"/;
		chomp;
		s/^\"//;
		s/\"*,*\}*;*\s*$//;
		my $line = $_;
		if ($isPixels) {
			# can we do this faster ?
			$pixels->[$pixCount] = [ $line =~ /$re/ ];
			#die "bad number of columns in xpm file $file\n"
			#	if ($#{@{$pixels->[$pixCount]}} != $def->[0]);
			$pixCount++;
		}
		elsif ($isColors) {
			$ids->[$count] = substr($line,0,$cpp);
			$line = substr($line,$cpp+1);
			$line =~ s/^\s*//;
			# suppress these stupids "s None"
			$line =~ s/s\s+none$//i;
			$line =~ s/^\s*c\s+//;
			$line =~ s/\s*$//;
			# encode in 16 bits per pixels ...
			die "bad color definition in $file" if ($line eq "");
			$colors->[$count]=encode16bpp($line);
			$count++;
			if ($count == $nc) {
				$isColors = 0;
				$isPixels = 1;
			}
		}
		else {
			$isColors = 1;
			$def = [ $line =~ /\s*(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/ ];
			for ($i=0;$i<4;$i++) {
				die "it does not seem that $file is an xpm (definition)"
					unless (defined($def->[$i]));
			}
			$nc = $def->[2];
			$cpp = $def->[3];
			$re = "(" . "." x $cpp . ")";
			$re = "$re" x $def->[0];
			$count++;
		}
	}
	close(XPM);
	# check if the format is ok:
	die "it does not seem that $file is an xpm\n"
		if ($count < 1 || !$isPixels || ($def->[1] != $pixCount));

	$xpm->{'def'} = $def;
	$xpm->{'colors'} = $colors;
	$xpm->{'ids'} = $ids;
  	$xpm->{'pixels'} = $pixels;
	return $xpm;
}

#-------------------------------------
# write an xpm to a file

sub writeXpm ($;$) {
	my $xpm = shift;
	my $file = shift || "";
	my $out ="";
	my $def = $xpm->{'def'};
	my $pixels = $xpm->{'pixels'};
	my $i;

	$out .= qq(/* XPM */\nstatic char *ft_xpm[] = {\n);
	$out .= qq(/* columns rows colors chars-per-pixel */\n);
	$out .= qq("@{$def}",\n);

	for($i = 0; $i < $def->[2]; $i++) {
		$out .= qq("$xpm->{'ids'}->[$i] c $xpm->{'colors'}->[$i]",\n);
	}
	$out .= "/* pixels */\n";

	for ($i=0; $i < $def->[1]; $i++) {
		$out .= qq(");
		$out .= join ("", @{$pixels->[$i]}[0 .. $def->[0]-1]);
		$out .= qq(",\n);
	}
	chomp($out);
	$out .= "\n};\n";

	if (defined($file)) {
		# use saveFile() from possible Util::FileSystem lib?
		open(OUT, ">$file") || die "Can't write $file: [$!]";
		print OUT $out;
		close(OUT);
	} else {
		print $out;
	}
}

#-------------------------------------
# create a monochrome xpm

sub createMonoXpm($$$) {
	my $columns = shift || 1;
	my $rows =  shift || 1;
	my $color = shift || "None";
	my $xpm; my $i; my $j;

	$xpm->{'def'} = [$columns, $rows, 1, 1];
	$xpm->{'colors'}->[0] = encode16bpp($color);
	$xpm->{'ids'}->[0] = " ";

	for ($i = 0; $i<$rows; $i++) {
		for ($j = 0; $j<$columns; $j++) { $xpm->{'pixels'}->[$i]->[$j] = " "; }
	}
	return $xpm;
}

#-------------------------------------
# get the color id from its nbr.
# we need the reverse function ...

sub getColorId($$) {
	my $nbr = shift;
	my $cpp = shift;
	my $id = "";
	my $k;

	my $max = 92**$cpp;
	return undef if ($max <= $nbr);

	for ($k = $cpp-1; $k >= 0; $k--) {
		$a = int($nbr / (92 ** $k));
		$id = substr($singleIdList, $a, 1) . $id;
		$nbr -= $a*(92 ** $k);
	}

	return $id;
}

#-------------------------------------
# add a new colors

sub addColor($$) {
	my $xpm = shift;
	my $color = shift;
	my $def = $xpm->{'def'};
	my $ids = $xpm->{'ids'};
	my $colors = $xpm->{'colors'};

	# does the color is already there?
	if (!$beFast) {
		my $i;
		for($i = 0; $i < $def->[2]; $i++) {
			return $ids->[$i] if $colors->[$i] eq "$color";
		}
	}

	# get the id for the new colors
	my $id = getColorId($def->[2], $def->[3]);

	if (defined($id)) {
		$def->[2]++;
	} else {
		$id = addACharPerPix($xpm); # and a dummy color
   }

	$ids->[$def->[2]-1] = $id;
	$colors->[$def->[2]-1] = $color;
	return $id;
}

#-------------------------------------
# add a char per Pixels and a dummy colors

sub addACharPerPix {
	my $xpm = shift;
	my $def = $xpm->{'def'};
	my $colors = $xpm->{'colors'};
	my $ids = $xpm->{'ids'};
	my $pixels = $xpm->{'pixels'};
	my $nc = $def->[2];
	my $i;

	$def->[3]++;
	@{$ids} = map { "$_ " } @{$ids};
	# add a dumy colors
	$ids->[$nc] = " " x ($def->[3]-1) . ".";
	$colors->[$nc] = $colors->[$nc-1];
	$def->[2]++;

	for ($i = 0; $i < $def->[1]; $i++) {
		@{$pixels->[$i]} = map { "$_ " } @{$pixels->[$i]};
	}
	return $ids->[$def->[2]-1];
}

#-------------------------------------
# Take 2 xpm $xpm and $mask of the same size and set the pixel
# of $xpm to $colors if the corresponding pixel of mask is black
# (i.e. #0* or grey0 or black).

sub applyTrans {
	my $xpm = shift;
	my $mask = shift;
	my $color = shift;
	my ($mcolors,$mids,$mpixels,$nc) = ($mask->{'colors'}, $mask->{'ids'},
		$mask->{'pixels'},$mask->{'def'}->[2]);
	my ($xpixels,$def) = ($xpm->{'pixels'},$xpm->{'def'});
	my ($done,$i) = (0, 0);
	my $j;
	my $t = "";

	# found the transparent id
	while($i < $nc && !$done) {
		my $tmp = $mask->{'colors'}->[$i];
		if ($mcolors->[$i] =~ /^#0*$/ ||
			$mcolors->[$i] =~ /^gray0$/i ||
			$mcolors->[$i] =~ /^black$/i) {
			$t = $mids->[$i];
			$done = 1;
		}
		$i++;
	}

	return if $t eq "";

	my $id = addColor($xpm,$color);

	for ($i=0; $i<$def->[1]; $i++) {
		for ($j=0; $j<$def->[0]; $j++) {
			$xpixels->[$i]->[$j] = $id if $mpixels->[$i]->[$j] eq "$t";
		}
	}

}

#-------------------------------------
# add border to an xpm

sub addBorder($$$$$$) {
	my ($xpm,$x1,$x2,$y1,$y2,$color) = @_;
	my $id = addColor($xpm,encode16bpp($color));
	my $columns = $xpm->{'def'}->[0];
	my $rows = $xpm->{'def'}->[1];
	my $pixels = $xpm->{'pixels'};
	my @addLeft = ();
	my @addRight = ();
	my $i;

	for ($i = 0; $i < $x1; $i++) { $addLeft[$i] = $id; }
	for ($i = 0; $i < $x2; $i++) { $addRight[$i] = $id; }
	my @new_row = ();
	for ($i=0; $i < $columns + $x1 + $x2; $i++) { $new_row[$i] = $id; }
	# shift the rows and add left and right border:
	for ($i = $rows + $y1 - 1; $i >= $y1; $i--) {
		@{$pixels->[$i]}= (@addLeft,
			@{$pixels->[$i-$y1]}[0..$columns-1],@addRight);
	}
	# add top border
	for ($i = 0; $i < $y1; $i++) { @{$pixels->[$i]} = @new_row; }
	# add bottom border
	for ($i = $rows + $y1 ; $i < $rows + $y1 + $y2; $i++) {
		@{$pixels->[$i]} = @new_row;
	}
	$xpm->{'def'}->[0] += $x1 + $x2;
	$xpm->{'def'}->[1] += $y1 + $y2;
}

#-------------------------------------
# tile an xpm

sub applyTile {
	my $xpm = shift;
	my $tile = shift;
	my $type = shift;
	my $x = shift || 0;
	my $y = shift || 0;

	my ($done,$i,$k) = qw(0 0 0);
	my $t = "";
	my %idConv = ();

	if ($type ne "center" && ($x != 0 || $y != 0)) {
		addBorder($xpm,$x,$x,$y,$y,"None");
	}

	my $columns = $xpm->{'def'}->[0];
	my $rows = $xpm->{'def'}->[1];

	if ($type eq "expand") {
		system("$magickPath/convert -geomerty $columns" .
			"x$rows" ."! $tile /tmp/ft-tmp-images.xpm");
		$tile = loadXpm("/tmp/ft-tmp-images.xpm");
		unlink("/tmp/ft-tmp-images.xpm");
		$type = "center";
	}

	# add border to $xpm
	if ($type eq "center") {
		my ($x1,$x2,$x3,$x4,$y1,$y2);
		my $tilecol = $tile->{'def'}->[0];
		my $tilerows = $tile->{'def'}->[1];
		my $x = $tilecol > $columns ? $tilecol-$columns : 0;
		my $y = $tilerows > $rows ? $tilerows-$rows : 0;

		if ($x/2 == int($x/2)) { $x1= $x2 = $x/2; }
		else { $x1 = int($x/2) + 1; $x2 = int($x/2); }
		if ($x/2 == int($y/2)) { $y1 =$y2 =$y/2; }
		else { $y1 = int($y/2) + 1; $y2 = int($y/2); }

		addBorder($xpm,$x1,$x2,$y1,$y2,"None");
		$columns = $xpm->{'def'}->[0];
  		$rows = $xpm->{'def'}->[1];
	}

	# add the $tile colors in $xpm
	my $tilenc = $tile->{'def'}->[2];
	my $tilecolors = $tile->{'colors'};
	my $tileids = $tile->{'ids'};
	for($i = 0; $i < $tilenc; $i++) {
		$idConv{"$tileids->[$i]"} = addColor($xpm,"$tilecolors->[$i]");
	}

	# found the transparent id
	my $xpmnc = $xpm->{'def'}->[2];
	my $colors = $xpm->{'colors'};
	my $ids = $xpm->{'ids'};
	$i = 0;
	while($i < $xpmnc && !$done) {
		if ($colors->[$i] =~ /^none$/i) { $t = $ids->[$i]; $done = 1; }
		$i++;
	}

	return if $t eq "";

	# add some space if need in the id hash
	my $xpmcpp = $xpm->{'def'}->[3];
	foreach $i (keys %idConv) {
		my $len = length($idConv{"$i"});
		$idConv{"$i"} .= " "x($xpmcpp-$len);
	}

	# apply the tile:
	my $pixels = $xpm->{'pixels'};
	my $tpixels = $tile->{'pixels'};
	for ($i = 0; $i < $rows; $i++) {
		my($j,$l) = (0, 0);
		for ($j = 0; $j < $columns; $j++) {
			if ($pixels->[$i]->[$j] eq "$t") {
				$pixels->[$i]->[$j] = $idConv{"$tpixels->[$k]->[$l]"};
			}
			$l = defined $tpixels->[$k]->[$l+1] ? $l+1:0;
		}
		$k = defined $tpixels->[$k+1]->[0] ? $k+1:0;
	}
}

#-------------------------------------
# colorize an xpm from jos-colorizexpm

sub colorizeXpm() {

	my $xpm = shift;
	my ($min,$max)= qw(255 0);
	my @tmp;
	my $colors = $xpm->{'colors'};

	die "colorize computation does not support polynomial interpolation\n"
		if $rizeComp =~ /^p/;

	my $nc = $xpm->{'def'}->[2];
	my @GREY = ();
	my $i;
	for ($i=0;$i<$nc;$i++) {
		next if $colors->[$i] =~ /^None$/i;
		my $t = bppTo3intArray($colors->[$i]);
		$GREY[$i] = greyval($t);
		if ($GREY[$i]<$min) {$min=$GREY[$i]};
		if ($GREY[$i]>$max) {$max=$GREY[$i]};
	}

	my $dx = 255; my $x1; my $x2;
	if ($rizeRule eq "min") {
		$x1=0;$x2=1;
	} else {
		# ??:  olicha: there is a problem if $dx < $min or $max ??
		#$dx = $max-$min;
		#$dx = 1 if $dx<=0;
		#$x1=$min/$dx;
		#$x2=$max/$dx;
		# I think this is better ? (see also the modification in interpolate)
		$x1 = $min/$dx;
		$x2 = $max/$dx;
	}

  	my $nbrColors = 0;
	my $rizeColors = [];
	@tmp = split(':',$rizeColorsOpt);

	if ($tmp[0] =~ /^\s*top\s*[[#A-Za-z]/) {
		$min = int($min);
		$tmp[0] =~ s/^\s*top\s*/top$min/;
	}
	if ($tmp[-1] =~ /^top[[#A-Za-z]/) {
		$max = int($max);
		$tmp[-1] =~ s/^\s*top\s*/top$max/;
	}

	my $c;
	foreach $c (@tmp) {
		$rizeColors->[$nbrColors] = bppTo3intArray(encode16bpp($c));
		$nbrColors++;
	}

	$transColor = encode16bpp("$transColor") if $transColor ne "";
	for ($i = 0; $i < $nc; $i++) {
		if ($colors->[$i] =~ /^None$/i) {
			$colors->[$i] = $transColor if $transColor ne "";
			next;
		}
		my $G=$GREY[$i]/$dx;
		# need a better fix
		$G = 1 if $G > 1;
		my $t=interpolateColors($rizeColors,$nbrColors,$G,$rizeComp,$i,$x1,$x2);
		$colors->[$i]=encode16bpp($t);
	}
}

#-------------------------------------
# rotate

sub rotateXpm($$) {
	my $xpm = shift;
	my $angle = shift || $rotate;
	my ($c,$r,$pixels)=($xpm->{'def'}->[0],$xpm->{'def'}->[1],$xpm->{'pixels'});
	my ($i,$j);
	my $np =[];

	if ($angle eq "0m" || $angle eq "-0m") {
		for ($i=0;$i<$r;$i++) { @{$pixels->[$i]}= reverse @{$pixels->[$i]} }
	}
	elsif ($angle eq "90") {
		for ($i=0;$i<$r;$i++) {
			for ($j=0;$j<$c;$j++) { $np->[$j]->[$i] = $pixels->[$i]->[$c-$j-1] }
		}
		@{$pixels} = @{$np};
		$xpm->{'def'}->[0] = $r; $xpm->{'def'}->[1] = $c;
	}
	elsif ($angle eq "90m") {
		for ($i=0;$i<$r;$i++) {
			for ($j=0;$j<=$c;$j++) { $np->[$j]->[$i]= $pixels->[$i]->[$j] }
		}
		$pixels = $np;$xpm->{'def'}->[0] = $r; $xpm->{'def'}->[1] = $c;
	}
	elsif ($angle eq "-90") {
		for ($i=0;$i<$r;$i++) {
			for ($j=0;$j<=$c;$j++) { $np->[$j]->[$i] = $pixels->[$r-$i-1]->[$j] }
		}
		@{$pixels} = @{$np};
		$xpm->{'def'}->[0] = $r; $xpm->{'def'}->[1] = $c;
	}
	elsif ($angle eq "-90m") {
		for ($i=0;$i<$r;$i++) {
			for ($j=0;$j<=$c;$j++) {
				$np->[$j]->[$i] = $pixels->[$r-$i-1]->[$c-$j-1]
			}
		}
		@{$pixels} = @{$np};
		$xpm->{'def'}->[0] = $r; $xpm->{'def'}->[1] = $c;
	}
	elsif ($angle eq "-180m") {
		for ($i=0;$i<$r;$i++) {
			for ($j=0;$j<=$c;$j++) { $np->[$i]->[$j] = $pixels->[$r-$i-1]->[$j] }
		}
		@{$pixels} = @{$np};
	}
	elsif ($angle eq "-180") {
		for ($i=0;$i<$r;$i++) {
			for ($j=0;$j<=$c;$j++) {
				$np->[$i]->[$j] = $pixels->[$r-$i-1]->[$c-$j-1]
			}
		}
		@{$pixels} = @{$np};
	}
	elsif ($angle ne "0" && $angle ne "-0") {
		die "rotate argument must be either 0[m], 90[m], -90[m], 180[m]".
			 " or -180[m]\n";
	}
}

#-----------------------------------------------------------------------------
# colors library
#-----------------------------------------------------------------------------

#-------------------------------------
# load the X rgb.txt file

sub loadRGB() {

	# return if it is already loaded
	return if defined $rgb{'gray0'};

	my $rgbFile = "";
	my $path = "";

	foreach (@xlibPath) {
		s/^-L//;
		$path = $_;
		$path .= "/X11/rgb.txt";
		$rgbFile = $path if -f $path;
	}

	die "X window rgb.txt file not found under @xlibPath" if $rgbFile eq "";

	open(RGB,"$rgbFile") || die "impossible to read $rgbFile";
	while(<RGB>) {
		if ( /^\s*(\d+)\s+(\d+)\s+(\d+)\s+(.+)\s*$/ ) {
			my $name = lc($4);
			my $a = int2hex($1);
			my $b = int2hex($2);
			my $c = int2hex($3);
			$rgb{"$name"} = "#$a$a$b$b$c$c";
		}
	}
	close(RGB);
}

#-------------------------------------
# Encode in 16 bits by pixels: we must be as general as possible
# and this is not a problem for the one which use 8bpp
# so I suggest we use 16 bpp and a 12 digit hex number as
# default encoding for colors. Then, if a function need to
# compute on the colors it will transform to the colors format it
# want and convert back to 16bpp in hex.

sub encode16bpp($) {
	my $color = shift;

	if (ref($color) eq "ARRAY") {
		# here we must be as fast as possible
		int2hexRef($color);
		return
			"#$color->[0]$color->[0]$color->[1]$color->[1]$color->[2]$color->[2]";
	}
	$color =~ s/^\s*//;
	$color =~ s/\s*$//;
	if ($color =~ /\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*/) {
		my ($a,$b,$c);
		$a = int2hex($1);
		$b = int2hex($2);
		$c = int2hex($3);
		return "#$a$a$b$b$c$c";
	}
	elsif ($color =~ /^\s*#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/) {
		return "#$1$1$2$2$3$3";
	}
	elsif ($color =~/^#[0-9a-fA-F]{12}$/) {
		return $color;
	}
	elsif ($color =~ /none/i) {
		return "None";
	}
	elsif ($color =~ /^random\s*(.*)$/i) {
		return randomColor($1);
	}
	elsif ($color =~ /^top(\d*)\s*(.+)$/i) {
		my $a;
		$a = $1;
		$a = 255 if $a eq "";
		return topColor($2,$a);
	}
	elsif ($color =~ /^hilight\s*(.+)$/i) {
		return hilightColor($1);
	}
	elsif ($color =~ /^shadow\s*(.+)$/i) {
		return shadowColor($1);
	}
	else {
		loadRGB();
		$color = lc("$color");
		return $rgb{"$color"} if (defined $rgb{"$color"});
	}

	warn "unknown color $color, set it to black\n";
	return "#000000000000";
}

#-------------------------------------
# 16bpp to a ref array (0-255,0-255,0-255)

sub bppTo3intArray($) {
	# can we be more fast?
	my $color = shift;
	my @a = $color =~ /#(..)..(..)..(..)/;
	@a=(hex($a[0]),hex($a[1]),hex($a[2]));
	return \@a;
}

#-------------------------------------
# ref array (0-255,0-255,0-255) to 16bpp

sub intArrayTo16bpp($) {
	encode16bpp($_);
}

#-------------------------------------
# the random color

sub randomColor {
	my $color = shift;
	my $a;

	$a->[0] = int(rand 256);
	$a->[1] = int(rand 256);
	$a->[2] = int(rand 256);

	return encode16bpp($a) if ($color eq "");

	# not terrible ... a better idea?
	$color = encode16bpp($color);
	my $b = bppTo3intArray($color);
	my $i;
	for ($i=0;$i<3;$i++) {
		$$b[$i] = int(($$a[$i] + 2*$$b[$i]) / 3);
	}
	return  encode16bpp($b);
}

#-------------------------------------
# top colors from jos-colorizexpm

sub topColor {
	my $color = shift;
	my $max = shift;

	$color = encode16bpp($color);
	my $a = bppTo3intArray($color);
	my $CenterG=greyval($a);
	$CenterG = 1 if $CenterG == 0;
	my $HI = $max/$CenterG;
	my $i;
	for ($i = 0; $i < 3; $i++) {
		$$a[$i] = int($$a[$i] * $HI);
		$$a[$i] = $$a[$i] > 255 ? 255 : $$a[$i];
	}
	return  encode16bpp($a);
}

#-------------------------------------
# from jos-colorset-cdegradient
# an hilight white is white ?
# migo: Yes for GTK style hilighting, no for motif.
# migo: fvwm algorithms are in libs/ColorUtils.c (2.2.4 is better).

sub hilightColor {
	my $color = shift;

	$color = encode16bpp($color);
	my $a = bppTo3intArray($color);
	my $i;
	for ($i = 0; $i < 3; $i++) {
		$a->[$i] = max(255/5, $a->[$i]);
  		$a->[$i] = min(255, ($a->[$i] * 130) / 100);  # was 110
  		$a->[$i] = int($a->[$i]);
	}
	return  encode16bpp($a);
}

#-------------------------------------
# from jos-colorset-cdegradient
# is this 0.9 official? What about 0.8
# Moreover a shadow black is black ?
# migo: Yes for GTK style hilighting, no for motif.

sub shadowColor {
	my $color = shift;

	$color = encode16bpp($color);
	my $a = bppTo3intArray($color);
	my $i;
	for ($i = 0; $i < 3; $i++) {
		$a->[$i] *= 0.7;  # was 0.9
		$a->[$i] = int($a->[$i]);
	}
	return  encode16bpp($a);
}


#--------------------------------------
# grey value of a ref (\d+,\d+,\d+) colors from jos-colorizexpm

sub greyval {
  	my $c = shift;
	return sqrt($$c[0]**2 + $$c[1]**2 + $$c[2]**2)/sqrt(3);
}

#-------------------------------------
# interpolate colors

sub interpolateColors {
	my $colors = shift;
	my $nc = shift;       # nbr of colors
	my $x = shift;
	my $type = shift;
	my $step = shift || 0;
	my $x1 = shift || 0; # $x1 and $x2 are used by colorizeXpm
	my $x2 = shift || 1;
	my @a = qw(0 0 0);
	my $c = $nc-1;
	my $i; my $j;

	if ($type =~ /^t/) {
		for ($i = 0; $i < 3 ; $i++) { $a[$i] = int(rand 256) }
		return \@a;
	}

	if ($type =~ /^c/) {
		$i= $step%$nc;
		@a = @{$colors->[$i]};
		return \@a;
	}

	die "you need to specify at least two colors in color list"
		if $c == 0;

	if ($type =~ /^p/) {
		for ($i =0 ; $i < 3; $i++) {
			for ($j = 0; $j < $nc; $j++) {
				my $inter = 1; my $k;
				for ($k = 0; $k < $nc; $k++) {
					next if $k == $j;
					$inter *= ($x - $k/$c) * ($c/($j-$k));
				}
				$a[$i] += $colors->[$j]->[$i] * $inter;
				$a[$i] = int ($a[$i]);
				$a[$i] = 255 if ($a[$i] > 255);
				$a[$i] = 0 if ($a[$i] < 0);
			}
		}
		return \@a;
	}

	# more reasonable interpolation:
	# try to be as fast as possible !
	$x *= $c;
	$j=0;
	while ($x > ($j+1)) { $j++ }
	my $t1 = $j == 0 ? $x1 * $c : $j;
	my $t2 = $j == $c-1 ? $x2 * $c : $j+1;
	my $d = 1 / ($t2-$t1);
	my $l = $j + 1;
	# faster than a loop?
	# in any case doing the int independently is faster. why?
	$a[0] = ($colors->[$j]->[0]*($t2-$x) + $colors->[$l]->[0]*($x-$t1)) * $d;
	$a[1] = ($colors->[$j]->[1]*($t2-$x) + $colors->[$l]->[1]*($x-$t1)) * $d;
	$a[2] = ($colors->[$j]->[2]*($t2-$x) + $colors->[$l]->[2]*($x-$t1)) * $d;
	if ($type =~ /^r/) {
		for ($i=0;$i<3;$i++) {
			$a[$i] = $a[$i] + (-(rand)+rand)*25;
			$a[$i] = 255 if ($a[$i] > 255);
			$a[$i] = 0 if ($a[$i] < 0);
		}
	}
	($a[0],$a[1],$a[2]) = (int($a[0]),int($a[1]),int($a[2]));
	return \@a;
}

#-------------------------------------
# integer to hexadecimal (from jos-colorfun)

# $h = int2hex(255); -> "ff"
sub int2hex {
	my $i= shift;
 	# modified for speed (olicha)
	my $h = $Hex[$i/16] . $Hex[$i%16];
  	return $h;
}

sub int2hexRef {
	my $a= shift;
	my $i;
	# must be as fast as possible
	$a->[0] = $Hex[$a->[0]/16] . $Hex[$a->[0]%16];
	$a->[1] = $Hex[$a->[1]/16] . $Hex[$a->[1]%16];
	$a->[2] = $Hex[$a->[2]/16] . $Hex[$a->[2]%16];
}

#-----------------------------------
# min and max

sub min {
	my ($a, $b) = @_;
	return ($a < $b) ? $a : $b;
}

sub max {
	my ($a, $b) = @_;
	return ($a > $b) ? $a : $b;
}


#-----------------------------------------------------------------------------
# my !xpm image lib :o)
#-----------------------------------------------------------------------------

sub hasMatte {
	my $file = shift;
	my $done= 0;
	my $r = 0;

	open(IDENT,"$magickPath/identify -verbose $file|");
	while (<IDENT>) {
		if (/matte/i && /true/i) { $r = 1; }
	}
	close(IDENT);
	return $r;
}

#-----------------------------------------------------------------------------
# The starndard functions


sub showHelp {
	print "The fvwm-themes images utility.\n";
	print "Usage: $scriptName [OPTIONS]\n";
	print "General Options:\n";
	print "\t--help              show this help and exit\n";
	print "\t--version           show the version and exit\n";
	print "\t--in-dir dir        The input directory\n";
	print "\t--out-dir dir       The main directory for output the images\n";
	print "\t--gnome             short cut for converting GNOME icons\n";
	print "\t--site              set the out dir to \$FT_DATADIR/tr-image\n";
	print "\t--create-symlink v  Create symlink for use with fvwm-themes\n";
	print "\t--update            only create images which are needed\n";
	print "\t--ft-install        short cut used by fvwm-themes installation\n";
	print "\t--verbose int       level of verbosity\n";
	print "Convert\n";
	print "\t--convert           convert images to XPM images\n";
	print "\t--[no]trans-filter  Apply a transparent filter\n";
	print "\t--threshold value   percentage of transparisation\n";
	print "\t--postfix str       add -str after 16x16, 48x48... to out dirs\n";
	print "\t--[no]build-48x48   build or not 48x48 XPM images\n";
	print "\t--[no]build-16x16   build or not 16x16 XPM images\n";
	print "\t--[no]build-56x56   build or not 56x56 XPM images\n";
	print "\t--[no]build-32x32   build or not 32x32 XPM images\n";
	print "\t--[no]build-tiles   build or not tiles XPM images\n";
	print "\t--preserve          build XPM images without size modification\n";
	print "\t--size-48x48 geo    Set the size of the 48x48 XPM icons\n";
	print "\t--size-16x16 geo    Set the size of the 16x16 XPM icons\n";
	print "\t--size-56x56 geo    Set the size of the 56x56 XPM icons\n";
	print "\t--size-32x32 geo    Set the size of the 32x32 XPM icons\n";
	print "\t--size-tiles geo    Set the size of the tiles XPM icons\n";
	print "\t--add-border-48x48  add border to the 48x48 XPM icons\n";
	print "\t--add-border-16x16  add border to the 16x16 XPM icons\n";
	print "\t--add-border-56x56  add border to the 32x32 XPM icons\n";
	print "\t--add-border-32x32  add border to the 56x56 XPM icons\n";
	print "\t--add-border-tiles  add border to the tiles XPM icons\n";
	print "ImageMagick\n";
	print "\t--magick-bpp value  number of bit per pixel used by ImageMagick\n";
	print "\t--magick-path path  Set the path of ImageMagick convert\n";
	print "\t--magick-colors n   Number of colors used by ImageMagick\n";
	print "\t--magick-space val  see the ImageMagick convert man page\n";
	print "Simple transformations\n";
	print "\t--rotate value      rotate and/or mirorr an XPM\n";
	print "\t--add-border opt    add border to an/all image(s)\n";
	print "\t--tile value        tile an/all image(s)\n";
	print "Colorize\n";
	print "\t--colorize          colorize an/all image(s)\n";
	print "\t--colorize-colors l list of colors for colorize\n";
	print "\t--trans-color col   set the transparent pixels to col pixels\n";
	print "\t--colorize-comp t   interpolation computation type for colorize\n";
	print "\t--colorize-rule v   colorization procedure\n";
	print "CDE sky\n";
	print "\t--cde-sky           produce cde like gradient and a lot more\n";
	print "\t--sky-colors l      list of colors for cde-sky\n";
	print "\t--pattern-file f    use pattern in file f for cde-sky\n";
	print "\t--pattern-type t    create some patterns\n";
	print "\t--pattern-xpm f     create a pattern from an XPM\n";
	print "\t--pattern-gap int   jump into the pattern\n";
	print "\t--sky-comp t        interpolation computation type for cde-sky\n";
	print "\t--be-fast           go fast but use more memory\n";
	print "Background\n";
	print "\t--set-background    set the root window with the XPM builded\n";
	print "\t--set-back-prog ex  set the command to set the root window\n";
	print "Colors Schemes\n";
	print "\t--colors-schemes    parse and create colors schemes\n";
	print "\t--text-colors       create text colors for colors schemes\n";
   print "\t--schemes-ext       file extention for a colors file\n";
	print "Colors\n";
	print "\t--show-xcolors      show a list of all xcolors\n";
	print "\t--show-xcolorsets   show a list of all xcolor sets\n";
	print "\t--show-color-info c show a full info for the specified color\n";
	print "\t\tGood luck!\n";
	exit 0;
}

sub showVersion {
	print "$version\n";
	exit 0;
}

sub wrongUsage {
	print STDERR "Try '$scriptName --help' for more information.\n";
	exit -1;
}

sub myPrint {
	my $deg = shift;
	my $string = shift;

	if ($verbose >= $deg) {
		print "$string";
	}

}

sub myDebug {

	my $flag = shift;
	my $string = shift;
	if ($debug =~ /$flag/ || $debug eq "main") {
		print "(".times.")\t[$flag] $string";
	}
	# note: for time eval it is better to use perl -d:DProf with dprofpp

}
__END__

# ---------------------------------------------------------------------------

=head1 NAME

fvwm-themes-images - fvwm-themes images and colors utility

=head1 SYNOPSIS

B<fvwm-themes-images>
B<--convert> or/and B<--rotate> value or/and B<--colorize> or/and
B<--tile> or/and B<--add-border> or B<--cde-sky> or B<--colors-schemes>
or B<--show-xcolors> or B<--show-xcolors-set> or B<--show-color-info> color 
or B<--help> or B<--version>
[ B<--in-dir> dir ]
[ B<--out-dir> dir ]
[ B<--in-file> file ]
[ B<--out-file> file ]
[ B<--gnome> ]
[ B<--site> ]
[ B<--create-symlink> value ]
[ B<--update> ]
[ B<--ft-install> ]
[ B<--verbose> int ]
[ B<--[no]trans-filter> ]
[ B<--threshold> int ]
[ B<--postfix> string ]
[ B<--[no]build-48x48> ]
[ B<--[no]build-16x16> ]
[ B<--[no]build-56x56> ]
[ B<--[no]build-32x32> ]
[ B<--[no]build-tiles> ]
[ B<--preserve> ]
[ B<--size-48x48> geo ]
[ B<--size-16x16> geo ]
[ B<--size-56x56> geo ]
[ B<--size-32x32> geo ]
[ B<--size-tile> geo ]
[ B<--add-border-48x48> +x+y:color ]
[ B<--add-border-16x16> +x+y:color ]
[ B<--add-border-56x56> +x+y:color ]
[ B<--add-border-32x32> +x+y:color ]
[ B<--add-border-tile> +x+y:color ]
[ B<--magick-bpp> 8/16 ]
[ B<--magick-path> path ]
[ B<--magick-colors> int ]
[ B<--magick-space> value ]
[ B<--add-border> +x+y:color ]
[ B<--colorize-colors> color1:color2... ]
[ B<--trans-color> color ]
[ B<--colorize-comp> value ]
[ B<--colorize-rule> value ]
[ B<--sky-colors> color1:color2... ]
[ B<--pattern-file> file ]
[ B<--pattern-type> value ]
[ B<--pattern-xpm> file ]
[ B<--pattern-gap> value ]
[ B<--pattern-y> value ]
[ B<--sky-comp> value ]
[ B<--be-fast> ]
[ B<--set-background> ]
[ B<--set-back-prog> exec ]
[ B<--text-colors> value ]
[ B<--schemes-ext> ext ]

=head1 DESCRIPTION

The aim of this script is to build images to be used by fvwm-themes.

=head2 Convert Images to XPM Images

fvwm-themes-images can convert images in various format
(especially PNG GNOME icons) into XPM images of various sizes. This
use ImageMagick plus some internal XPM manipulations (to get
better results). For example, if you run:

	fvwm-themes-images --convert --gnome

then, if GNOME is not installed in an exotic way all icons
in the GNOME images directory will be converted into 48x48 and 16x16
XPM icons under ~/tr-images (if GNOME is not found the
images in /usr/share/pixmaps will be converted). To control the
result of the conversion you can use the --threshold
and --magick-colors option below. If the result is very very bad you must use
the --magick-bpp option.

You can also convert an individual images by using the --in-file and
--out-file option.

=head2 Other transformations

fvwm-themes-images can perform other transformations (which do not require
ImageMagick). You can colorize, rotate, add border and tile an XPM
images. These operations can be done together (and with "convert")
for all images in a directory or for an individual image.
For example, if you want blue/red mirrored gnome icons tiled with
a-48x48-tile.xpm for 48x48 icons and tiled with a-16x16-tile.xpm for
16x16 icons and with a yellow border of 5 pixels for 48x48 icons and of
2 pixels for 16x16 icons just run fvwm-themes-images with the following
options :o)

	--gnome --convert --rotate 0m \
	--colorize --colorize-colors blue:red \
	--tile-48x48 path_to/a-48x48-tile.xpm \
	--tile-16x16 path_to/a-16x16-tile.xpm \
	--add-border-48x48 +5+5:yellow \
	--add-border-16x16 +2+2:yellow

=head2 Colorize

fvwm-themes-images can colorize an XPM image (or a family of images
in a directory). The main aim of "colorize" is to produce an infinite
number of backgrounds with only one xpm. For examples:

	fvwm-themes-images --colorize --colorize-colors black:red \
	--trans-color yellow --in-file My.xpm --set-background

will tile your root window with an XPM build from My.xpm, such that
the darkest pixels in My.xpm are replaced by black pixels, the lightest
pixels are replaced by red pixels, the pixels in between are
interpolated between black and red and the transparent pixels are
replaced by yellow pixels. Moreover, you can use more than 2 colors
and some options allows you to control the interpolation.
You can also rotate, tile and borderize your XPM.
By default, fvwm-themes-images use xpmroot as "background
program" you can specify an other program with the --set-back-prog
option, e.g., if you want to use xv just add the option

	--set-back-prog "xv -root -quit"

Note that if you do not specify an out-file, the builded XPM
is saved in /tmp/$USER-ft-back.xpm.

=head2 CDE-SKY

fvwm-themes-images can set the root display to a gradient pattern like
CDE does. CDE has an option to display a gradient on the background,
which consists of a repeated pattern, but along the color
gradient, the color of the pattern varies. Try:

	fvwm-themes-images --cde-sky --sky-colors \
	turquoise:darkblue --set-background

in this case the default pattern file is used
($FT_DATADIR/themes/cde/background/pattern). A pattern file must contain a
rectangular pattern consisting of +es and -es like this:

	+++++
	+-+-+
	-+-+-
	-----

and nothing else. This pattern is painted repeatedly over the
screen. However, the colors change in the y direction accordingly
with the --sky-colors and --sky-comp options. fvwm-themes-images
can generate some pattern. If you want a regular gradient add the
option: --pattern-type uniform:1, try also the --pattern-type
option with square:50 or altern:20 and random:50 for examples.
If you want an horizontal gradient just rotate: --rotate 90.
You can also control the gradient computation. Try: --pattern-type
square:50 --sky-comp c for a chess like background, --pattern-type
altern:50 --sky-comp c for a band background, --pattern-type 1
--sky-comp r for an irregular gradient, and --pattern-type 1
--sky-comp t for an horrible background.
Note that if your sky contains a lot of coulours you can speed a
lot the construction of you sky by using the --be-fast option
(but this will build a bigger XPM).

=head2 COLORS SCHEMES

A color scheme file is a file constituted of one color by line.
At the present time fvwm-themes-images can add to a color scheme
file the text colors. For example, if you have in a directory DIR
some color scheme files with .dp as extension if you run:

	fvwm-themes-images --colors-schemes --text-colors \
	8:128:color1:color2 --in-dir DIR --out-dir DIR

then the 8 first colors of the color schemes files will be unchanged
and 8 new colors will be added (if your original colors files have more
than 8 colors these colors are ignored/removed). So, you get colors
files with 16 colors. The ith new color (the color of the (i+8)th line)
is the "text color" of the ith original color. The new colors are either
color1 or color2. The ith new color is color1 if the ith original color
have a grey value <= 128 and is color2 if not. A grey value of 255
correspond to white and a grey value of 0 correspond to black. So, the
idea is to use a light color for color1 (as white) and a dark color for
color2 (as black).

=head2 COLORS

When giving colors to fvwm-themes-image, you can use X colors name
(blue, turquoise, ...etc.), 8bits hexadecimal number
(#0000ff, #40e0d0, ...etc.), 16bits  hexadecimal number (#00000000ffff,
#0404e0e0d0d0, ...etc) or an array of 3 decimal numbers between 0 and 255
([0,0,255], [64,224,208], ...etc.). All these numbers represent the
red, green and blue values of the colors. To get the list of your X colors
which have a name with the corresponding value in 8bits and in an array
of 3 integer just type:

	fvwm-themes-images --show-xcolors | less

if you use hexadecimal numbers like B<#abcdef> in some shells you must put
these colors in quotes. Note, if you give colors by hexadecimal numbers
fvwm-themes-images is faster, since rgb.txt should not be loaded.

fvwm-themes-images have some generic ways to create colors. You can
give to fvwm-themes-images a color of the form:

	typecolor

where type is either top[integer], hilight, shadow, random and
where color is a color encoded as explained above. If you give
such a color fvwm-themes-images compute for you the "type" color
of the "color". To see the result of these computations for
all the colors which have name try:

	fvwm-themes-images --show-xcolorsets | less

for any individual color type:

	fvwm-themes-images --show-color-info color

You can enter random alone, this try to produce a random color. The only
type which does not have a clear meaning is "top". top may have an integer
between 0 and 255 after it (default is 255). top255 will purify your
color as top0 will destroy it completely to black. Typically, top255blue
will give blue, top255darkblue will give blue, top50blue will give a
very dark blue. The top type (without integer argument) is used in a
special way with the --colorize-colors option: if you want to colorize
an XPM with "color" as a "center color" try the following:

	fvwm-themes-images --colorize --colorize-colors \
	topcolor:topcolor --in-file My.xpm --set-background

then, fvwm-themes-images will try to find the good integer values
to top to produce the two good colors.

=head1 OPTIONS

=head2 General Options

B<--help>    - show the help and exit

B<--version> - show the version and exit

B<--in-dir> dir - The input directory. Default is the working directory
of the shell that will run fvwm-themes-images. You can give either a complete
path or a relative path (relative to the working directory).
With the --gnome option fvwm-themes-images will try to find the GNOME icons
directory, if GNOME is not found the default is /usr/share/pixmaps.

B<--out-dir> dir - The main directory for output the images. Default
is $HOME/tr-images and $FT_DATADIR/tr-images where $FT_DATADIR
is the fvwm-themes installation directory with the --site option.
You can give either a complete path or a relative path (relative
to the working directory).

B<--in-file> file - input file relatively to the --in-dir option
except if you give a complete path.

B<--out-file> file - output file if you use the --in-file option
and not --convert. You can give either a complete
path or a relative path (relative to the --out-dir option, i.e.,
$HOME/tr-images or $FT_DATADIR/tr-images). Yes, this is strange but
this is good. With --convert this option is ignored, with --set-background
you do not need to define an outfile: /tmp/$USER-ft-back.xpm is used.

B<--site> equivalent to --out-dir $FT_DATADIR/tr-images.

B<--update> if the file to be created already exist skip it. This is
useful for example after you have installed some new GNOME applications
and you do not want to rebuild all your xpm icons, with --update only
the new icons are builded.

B<--gnome> imply --convert, --postfix gnome, and try to find the GNOME icons
directory to define the --in-dir, if GNOME is not found --in-dir is set
to /usr/share/pixmaps

B<--ft-install> equivalent to --gnome (so --convert) --site --update
--create-symlink

B<--create-symlink> A:B - where A and B are either 48x48, 16x16, 32x32.
Create symbolic link from $FT_DATADIR/images/norm-postfix to OUT/A-postfix
and from $FT_DATADIR/images/mini-postfix to OUT/B-postfix. Where postfix
is defined with the --postfix option and where OUT is the directory
defined by --out-dir.

B<--verbose> int - where int can be 0, 1 or 2. This integer represent
the level of "verbosity". Default is 1, but with set-background, in this
case the default is 0.

=head2 Convert

B<--convert> - Will cause fvwm-themes-images to convert all images
in the directory specified by the --in-dir options into XPM icons
of various sizes. By default, XPM icons of sizes 48x48 and 16x16
are build in dir/48x48 and dir/16x16 where dir is he directory specified
by the --out-dir option

B<--[no]trans-filter> - Apply or not the internal "transparent filter".
Default is --trans-filter and this filter can be controlled with the
--threshold option below.
When ImageMagick convert a PNG image into an XPM one the result is not
perfect (or I have not found the good procedure). The problems is that
a PNG image has a "matte" channel which represent the degree of
transparency/opacity of the images. On the other hands, an XPM image has
a binary matte channel (a pixel is either opaque or transparent).
The "transparent filter" extract the matte channel (using ImageMagick),
then "threshold" it (using again ImageMagick) to get  the "good"
transparency zone which is applied to the XPM image using an internal
procedure (Maybe ImageMagick combine can do that but I never found
the good procedure). If you have bad result try to use
the --magick-bpp options.

B<--threshold> value - value must be an integer between 0 and 100
and represent a percentage. This value is used by the "transparent filter"
to compute the transparency zone of the builded XPM icons. More the value
is big more the resulting images are transparent. For GNOME icons you may
try value between 30 to 99 (a value of 100 will give a family of
empty icons as a value of 0 will probably give to you icons with a
black background). Default is 70.

B<--postfix> str - add "-str" to the name of the output directories of the
converted images: OUTDIR/48x48-str, OUTDIR/16x16-str ...etc.

B<--[no]build-48x48> - build or not the 48x48 XPM icons. Default is
--build-48x48.

B<--[no]build-16x16> - build or not the 16x16 XPM icons. Default is
--build-16x16.

B<--[no]build-56x56> - build or not the 56x56 XPM icons (under 56x56/).
Default is --nobuild-56x56.

B<--[no]build-32x32> - build or not the 32x32 XPM icons (under 32x32/).
Default is --nobuild-32x32.

B<--[no]build-tiles> - build or not the tiles XPM icons from the
tiles sub directory of the --in-dir option (under tiles/). Default is
--nobuild-tiles.

B<--preserve> - Set to no all the 5 previous options and convert without
size modifications under the out-dir.

B<--size-48x48> geometry - Set the size of the 48x48 XPM icons via an
ImageMagick size geometry. See the --size option of "man convert".
Default is 48x48.

B<--size-16x16> geometry - As above for the 16x16 XPM icons.
Default is 17x17 :)

B<--size-56x56> geometry - As above for the 56x56 XPM icons. Default is 56x56.

B<--size-32x32> geometry - As above for the 32x32 XPM icons. Default is 32x32.

B<--size-tiles> geometry - As above for the tiles XPM icons. Default is "".

B<--add-border-48x48> +x+y:color - add border for the 48x48 XPM icons. See
the --add-border option for details.

B<--add-border-16x16> +x+y:color - As above for the 16x16 XPM icons.

B<--add-border-56x56> +x+y:color - As above for the 16x16 XPM icons.

B<--add-border-32x32> +x+y:color - As above for the 32x32 XPM icons.

B<--add-border-tile> +x+y:color - As above for the tiles XPM icons.

B<--tile-48x48> rule:file - tile the 48x48 XPM icons with the xpm file
following the rule "rule". See the ---tile option for details.

B<--tile-16x16> rule:file - As above for the 16x16 XPM icons.

B<--tile-56x56> rule:file - As above for the 56x56 XPM icons.

B<--tile-32x32> rule:file - As above for the 32x32 XPM icons.

B<--tile-tiles> rule:file - As above for the tiles XPM icons.

=head2 ImageMagick Options

B<--magick-colors> value - Number of colors used. Default is 256. If
you use X under 16bpp (xdpyinfo) you can use for example 65536.

B<--magick-space> value - Where value must be GRAY, OHTA, RGB, Transparent,
XYZ, YCbCr, YIQ, YPbPr, YUV, or CMYK. See the -colorspace option of
ImageMagick (man convert). Default is Transparent.

B<--magick-path> path - set the path of the convert ImageMagick executable.
Useful if convert ImageMagick executable is not in your PATH or to test
different versions.

B<--magick-bpp> value - value must be 8 or 16. Set the number of bit per
pixels used by ImageMagick. This is a compile time option of ImageMagick
and fvwm-themes-images will detect it if you use a recent version of
ImageMagick. If fvwm-themes-images does not found this value it is set
to 16. This is very important for the --threshold option above.

=head2 Other Simple Transformations

B<--tile> [rule:][+x+y:]file_or_color - where rule can be "expand",
"center", "color" or nothing, where x and y are integers
and where file_or_color is a
xpm tile file or a color in the "color" case. Without "rule" the
xpm file will be tiled as usual on the background of the image.
With "expand" the tile file will be resized to fit the image.
With "center" the image is centered  on the tile file (your tile
file have to be bigger that your image). With "color" the background
of the image will be colorized by the color. The +x+y option can
be used with all the rules but the "center" rule. This option expand the
zone to tile by x pixels in the left and
the right of the image and y  pixels in the top and
the bottom of the image.

B<--add-border> +x+y:color - add x color pixels in the left and
the right of the image and y color pixels in the top and
the bottom of the image.

B<--rotate> value - value can be 0m, 90, 90m, 180, 180m. The integer
is the degree of the rotation the "m" says to also mirror the image.

=head2 Colorize

B<--colorize-colors> - Colorize an XPM image such that
the darkest pixels are replaced by pixels with the first color in the
color list below and the lightest pixels are replaced by pixels with
the last color in the list below. The pixels in between are
interpolated between these two colors and the colors in between.
Moreover the transparent pixels can be replaced by opaque pixels
with the --trans-color option. The type of the interpolation can
be changed with the --colorize-comp. If you found that your resulting
XPM is too contrasted you can try the "--colorize-rule min" option
(or change the color list).

B<--colorize-colors> color1:color2... - list of colors for colorization.
The top type (without integer argument) is used in a
special way here. If you use top with the first color and/or the last
color fvwm-themes-images will try to find the good integer values
to top to do so that these colors are "centred" in the colorization.

B<--trans-color> color - set the transparent pixels to color pixels.

B<--colorize-comp> type - type of the computation for the interpolation.
Type can be "l" for linear (this is the default), "r" for perturbed (as
linear but the colors obtained is randomly perturbed), "c" for
circular (the colors in the list are used alternatively), "t" for totally
random (then the list of colors are ignored and the pixels are colorized
randomly ... this is funny).

B<--colorize-rule> value - value can be max or min, default is max. max
does nothing. min change the way of the colorization: black is "mapped"
to the first color in the list and white  is "mapped" to the last color
in the list.

=head2 CDE SKY

B<--cde-sky> -  Create a "gradient" XPM which consists of a repeated
pattern, but along the color gradient, the color of the pattern varies.
A pattern file must contain a rectangular pattern consisting of +es and
-es. This pattern is painted repeatedly over the screen.
However, the colors change in the y direction accordingly
with the --sky-colors and --sky-comp options. By default, the pattern
used is $FT_DATADIR/themes/cde/background/pattern. You can use one
of the --pattern-* option below to load or create other patterns.
Finally, you can rotate your image to get horizontal gradient.

B<--sky-colors> color1:color2... - List of the colors for creating
the "gradient".

B<--pattern-file> file - use the pattern file "file" as pattern.

B<--pattern-type> type[[:x]:y] - where type can be uniform, altern,
square, random and where x and y are positive integers. If no type
is specified uniform is used, default x is 1 and default y is 8
but for square which is x. uniform creates a pattern with x rows
of y +, altern creates a pattern with x rows of y + followed
by y rows of -, square create a pattern of x rows constituted
of y + followed by y -, random create a pattern with x random rows
of length y.

B<--pattern-xpm> file - Produce the pattern file from an xpm file.
Set to - the transparent color and to + the other colors.

B<--pattern-gap> n - where n is a positive integer. Take in account
only the xnth lines of the pattern.

B<--pattern-y> y - where y is a positive integer. By default, the
XPM file produced by --cde-sky has the same height of your screen
to produce complete gradient. You can set this height to a smaller
value with this option to get repeated gradient or to save memory
and time with some patterns and some --sky-comp options.

B<--sky-comp> type - type of the computation for computing the gradient.
The type are the same as for --colorize-comp but you can use also "p"
for a polynomial interpolation.

B<--be-fast> - If your sky contains a lot of colors you can use this
option so that the background appear more rapidly on your root window.
On the other hands, the XPM file builded will be larger.

=head2 Set the Background

B<--set-background> - Set the background with the XPM file produced.
Of course, this work only for a "transformation" which produce
only one file (I.e., with the --in-file without --convert or with
--cde-sky).

B<--set-back-prog> exec - to execute "exec out.xpm" to set the background.
Default is xpmroot.

=head2 COLORS SCHEMES

B<--colors-scheme> - Parse and modify colors scheme files in a directory.
A color scheme file is a file constituted of one color by line.

B<--text-colors> l:g:color1:color2 - where l and g are integer. Transform
a colors scheme file "orig" to a color scheme file "new" as follows: 
1. the l first colors (i.e., lines) of "new" are the l first colors of 
"orig"; 
2. "new" have 2l lines the l new lines are the text colors of the
l first colors "respectively".
3. the text color of a color is color1 if the color has a grey value
which is <= g and is color2 if not.

B<--schemes-ext> ext - consider only the files with ".ext" at the end of
its name as a colors scheme file. Default is "dp".

=head2 Colors Informations

B<--show-xcolors> - show a list of all colors with an X name.

B<--show-xcolorsets> - show a list of all "xcolors sets"

B<--show-color-info color> - show full informations for the specified color

=head1 AUTHORS

Olivier Chapuis <olivier.chapuis@free.fr> (general design, convert, simple
transformations, internal xpm library, interpolation, amelioration in
"colorize" and cde-sky). 22 July 2000.

Jos van Riswick  <josvanr@xs4all.nl> (Colorize, cde-sky, numerous
functions in the colors "library").

The starting point of this script is the fvwm2gnome script written
by Clarence Smith, Jr
<csmith@staticbomb.com> and Jer Warren <jer@digitalaccess.net>,
where ImageMagick is used to convert GNOME icons into 20x20 XPM icons.

=head1 COPYING

The script is distributed by the same terms as fvwm itself.
See GNU General Public License for details.

=head1 BUGS

The english of this man page have to be fixed.

Report bugs to fvwm-themes-devel@lists.sourceforge.net.

=cut

# ==========================================================================

